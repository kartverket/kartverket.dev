import { VulnerabilityTable } from './VulnerabilityTable';
import Typography from '@mui/material/Typography';
import {
  ClusterMap,
  ClusterSummary,
  NamespaceMap,
  Vulnerability,
} from '../../typesFrontend';
import { Box } from '@mui/system';
import ThumbUpIcon from '@mui/icons-material/ThumbUp';

type Props = {
  vulnerabilities: Vulnerability[];
  componentName: string;
};

const sortById = (a: Vulnerability, b: Vulnerability) =>
  a.vulnerabilityId.localeCompare(b.vulnerabilityId);

const buildClusterMap = (vulnerabilities: Vulnerability[]): ClusterMap => {
  const clusters: ClusterMap = new Map();

  vulnerabilities.forEach(vulnerability => {
    const info = vulnerability.scannerSpecificInfo.sysdigInfo;
    if (!info) return;

    info.locations.forEach(loc => {
      const perNamespace =
        clusters.get(loc.cluster) ??
        (clusters.set(loc.cluster, new Map()), clusters.get(loc.cluster)!);
      const list =
        perNamespace.get(loc.namespace) ??
        (perNamespace.set(loc.namespace, []), perNamespace.get(loc.namespace)!);

      if (!list.some(x => x.vulnerabilityId === vulnerability.vulnerabilityId))
        list.push(vulnerability);
    });
  });

  return clusters;
};

const groupNamespacesWithSameVulnerabilities = (
  namespaceMap: NamespaceMap,
): { namespaces: string[]; vulnerabilities: Vulnerability[] }[] => {
  const groupsByCve = new Map<
    string,
    { namespaces: string[]; vulnerabilities: Vulnerability[] }
  >();

  Array.from(namespaceMap.entries()).forEach(([namespace, vulnerabilities]) => {
    const key = [...vulnerabilities]
      .sort(sortById)
      .map(v => v.vulnerabilityId)
      .join('|');
    const group =
      groupsByCve.get(key) ??
      (groupsByCve.set(key, {
        namespaces: [],
        vulnerabilities: [...vulnerabilities].sort(sortById),
      }),
      groupsByCve.get(key)!);
    group.namespaces.push(namespace);
  });

  return Array.from(groupsByCve.values())
    .map(group => ({
      namespaces: group.namespaces.sort((a, b) => a.localeCompare(b)),
      vulnerabilities: group.vulnerabilities,
    }))
    .sort((a, b) => a.namespaces[0].localeCompare(b.namespaces[0]));
};

const buildClusterSummaries = (
  vulnerabilities: Vulnerability[],
): ClusterSummary[] => {
  const clusterMap = buildClusterMap(vulnerabilities);

  return Array.from(clusterMap.entries())
    .map(([clusterName, namespaceMap]) => ({
      clusterName,
      groups: groupNamespacesWithSameVulnerabilities(namespaceMap),
    }))
    .sort((a, b) => a.clusterName.localeCompare(b.clusterName));
};

export const RuntimeVulnerabilityTable = ({
  vulnerabilities: allVulnerabilities,
  componentName,
}: Props) => {
  const clusterSummaries = buildClusterSummaries(allVulnerabilities);

  return (
    <Box>
      {clusterSummaries.length === 0 ? (
        <Box display="flex" m={2} gap={1}>
          <Typography fontWeight={500}>Ingen sårbarheter funnet</Typography>
          <ThumbUpIcon color="success" fontSize="medium" />
        </Box>
      ) : (
        clusterSummaries.map(({ clusterName, groups }) => (
          <Box key={clusterName}>
            <Typography fontWeight="bold" m={1} mt={2}>
              {clusterName}
            </Typography>

            {groups.map(({ namespaces, vulnerabilities }) => (
              <Box key={namespaces.join(',')}>
                <Typography m={1} mt={2} mb={2}>
                  Namespace{namespaces.length === 1 ? ': ' : 's: '}
                  {namespaces.join(', ')} ({vulnerabilities.length} sårbarhet
                  {vulnerabilities.length === 1 ? '' : 'er'})
                </Typography>

                <VulnerabilityTable
                  vulnerabilities={vulnerabilities}
                  componentName={componentName}
                  initialRowsPerPage={5}
                />
              </Box>
            ))}
          </Box>
        ))
      )}
    </Box>
  );
};
