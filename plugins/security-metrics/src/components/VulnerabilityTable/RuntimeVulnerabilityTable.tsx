import { VulnerabilityTable } from './VulnerabilityTable';
import Typography from '@mui/material/Typography';
import { Vulnerability } from '../../typesFrontend';
import { Box } from '@mui/system';
import ThumbUpIcon from '@mui/icons-material/ThumbUp';

type Props = {
  vulnerabilities: Vulnerability[];
  componentName: string;
};

const makeLocationString = (cluster: string, namespace: string) => {
  return `${cluster} ${namespace}`;
};

const getClusters = (vuln: Vulnerability): string[] => {
  const clusters = vuln.scannerSpecificInfo.sysdigInfo?.clusters;
  if (!clusters) return [];
  return Array.isArray(clusters) ? clusters : [clusters];
};

const getNamespace = (vuln: Vulnerability): string => {
  return vuln.scannerSpecificInfo.sysdigInfo?.namespace ?? 'Ukjent namespace';
};

const getLocations = (vuln: Vulnerability): string[] => {
  const namespace = getNamespace(vuln);
  return getClusters(vuln).map(cluster =>
    makeLocationString(cluster, namespace),
  );
};

export const RuntimeVulnerabilityTable = ({
  vulnerabilities,
  componentName,
}: Props) => {
  const mergedById = vulnerabilities.reduce(
    (acc, vuln) => {
      const id = vuln.vulnerabilityId;
      if (!acc[id]) {
        acc[id] = {
          vuln,
          locations: new Set<string>(),
        };
      }
      getLocations(vuln).forEach(loc => acc[id].locations.add(loc));
      return acc;
    },
    {} as Record<
      string,
      {
        vuln: Vulnerability;
        locations: Set<string>;
      }
    >,
  );

  const vulnsWithLocationSets = Object.values(mergedById).map(
    ({ vuln, locations }) => {
      const locationList = Array.from(locations).sort();
      return {
        vuln,
        locationList,
        locationKey: locationList.join(' | '),
      };
    },
  );

  const groupsByLocationSet = vulnsWithLocationSets.reduce(
    (acc, item) => {
      if (!acc[item.locationKey]) {
        acc[item.locationKey] = {
          sharedLocations: item.locationList,
          vulns: [] as Vulnerability[],
        };
      }
      acc[item.locationKey].vulns.push(item.vuln);
      return acc;
    },
    {} as Record<
      string,
      {
        sharedLocations: string[];
        vulns: Vulnerability[];
      }
    >,
  );

  const multiLocationGroups = Object.values(groupsByLocationSet)
    .filter(g => g.sharedLocations.length > 1)
    .sort((a, b) => {
      if (b.sharedLocations.length !== a.sharedLocations.length) {
        return b.sharedLocations.length - a.sharedLocations.length;
      }
      return a.sharedLocations
        .join(', ')
        .localeCompare(b.sharedLocations.join(', '));
    });

  return (
    <Box>
      {multiLocationGroups.length === 0 ? (
        <Box display="flex" m={2} gap={1}>
          <Typography fontWeight={500}>
            Ingen sårbarheter som finnes i flere miljøer/namespaces
          </Typography>
          <ThumbUpIcon color="success" fontSize="medium" />
        </Box>
      ) : (
        multiLocationGroups.map(group => (
          <Box key={group.sharedLocations.join('|')} mb={3}>
            <Typography fontWeight="bold" m={2}>
              {group.sharedLocations.join(', ')} ({group.vulns.length} sårbarhet
              {group.vulns.length === 1 ? '' : 'er'})
            </Typography>

            <VulnerabilityTable
              vulnerabilities={group.vulns}
              componentName={componentName}
              initialRowsPerPage={5}
            />
          </Box>
        ))
      )}
    </Box>
  );
};
